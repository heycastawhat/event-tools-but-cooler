<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <script src="assets/pdf.min.js"></script>
    <script src="theme.js"></script>
    <script src="sync.js"></script>
    <title>Display - Event Suite</title>
</head>
<body>

    <div id="scene-standby" class="scene active">
        <div class="standby-content">
            <div class="standby-text">Waiting for controller...</div>
            <div class="standby-dots"><span></span><span></span><span></span></div>
            <button id="goFullscreenBtn" class="fullscreen-btn" onclick="goFullscreen()">Go Fullscreen</button>
            <button id="revealSceneBtn" style="display:none;margin-top:2rem;padding:1rem 2rem;font-size:1.25rem;border-radius:8px;border:none;background:var(--accent);color:#fff;">Show Display</button>
        </div>
    </div>

    <div id="scene-welcome" class="scene">
        <div class="welcome-bg"></div>
        <div class="welcome-content">
            <div class="welcome-title" id="welcomeTitle">Event Tools</div>
        </div>
    </div>

    <div id="scene-teams" class="scene">
        <div class="scene-label">Teams</div>
        <div id="teamsGrid" class="teams-display-grid"></div>
    </div>

    <div id="scene-scoreboard" class="scene">
        <div class="scene-label">Leaderboard</div>
        <div id="scoreboardList" class="scoreboard-list"></div>
    </div>

    <div id="scene-timer" class="scene">
        <div class="timer-wrap">
            <div class="timer-mode-label" id="timerModeLabel">Stopwatch</div>
            <div class="timer-digits" id="timerDigits">00:00:00</div>
            <div id="timerControls" style="margin-top:1.5rem;display:flex;gap:1rem;justify-content:center;">
                <button class="timer-btn" onclick="adjustCountdown(60000)">+1 min</button>
                <button class="timer-btn" onclick="adjustCountdown(10000)">+10 sec</button>
                <button class="timer-btn" onclick="adjustCountdown(-10000)">-10 sec</button>
                <button class="timer-btn" onclick="adjustCountdown(-60000)">-1 min</button>
            </div>
        </div>
    </div>

    <div id="scene-picker" class="scene">
        <div class="picker-wrap">
            <div class="picker-label">Random Pick</div>
            <div class="picker-window">
                <div class="picker-reel" id="pickerReel"></div>
            </div>
            <div class="picker-winner" id="pickerWinner"></div>
        </div>
        <div class="picker-confetti" id="pickerConfetti"></div>
    </div>

    <!-- schedule scene removed -->

    <div id="scene-message" class="scene">
        <div class="message-wrap">
            <div class="message-text" id="messageText"></div>
            <div class="message-subtitle" id="messageSubtitle"></div>
        </div>
    </div>

    <div id="scene-ambient" class="scene">
        <div id="ambientContainer" style="position:relative;width:100%;height:100%;overflow:hidden;">
            <canvas id="ambientCanvas" style="position:absolute;top:0;left:0;width:100%;height:100%;"></canvas>
            <div id="ambientOverlay" style="position:absolute;inset:0;pointer-events:none;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:0.5rem;">
                <div id="ambientLogo" style="pointer-events:auto;font-size:4rem;font-weight:800;color:var(--text-primary);text-shadow:0 6px 30px rgba(0,0,0,0.6);display:none;">Event Suite</div>
                <div id="ambientText" style="font-size:3rem;font-weight:700;color:#fff;text-shadow:0 4px 20px rgba(0,0,0,0.7);text-align:center;padding:0 2rem;display:none;"></div>
            </div>
        </div>
    </div>

    <div id="scene-waiting" class="scene">
        <div class="waiting-wrap">
            <div class="waiting-label">Time Wasted</div>
            <div class="waiting-time" id="waitingTime">00:00</div>
            <div class="waiting-sub" id="waitingSub"></div>
        </div>
    </div>

    <div id="scene-slides" class="scene">
        <div class="slides-counter" id="slidesCounter"></div>
        <div class="slides-content" id="slidesContent">
            <div class="slides-empty">No slides loaded</div>
        </div>
    </div>

    <div id="scene-camera" class="scene">
        <video id="cameraVideo" class="camera-video" autoplay playsinline></video>
        <div class="camera-status" id="cameraStatus">Waiting for camera...</div>
    </div>

    <div class="attention-flash" id="attentionFlash"></div>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            width: 100vw;
            height: 100vh;
        }

        .scene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            background: var(--bg-primary);
        }

        .scene.active {
            opacity: 1;
            pointer-events: auto;
        }

        .scene-label {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        /* Welcome */
        .welcome-bg {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, #0d1117 0%, #161b22 25%, #1a1e2e 50%, #161b22 75%, #0d1117 100%);
            background-size: 400% 400%;
            animation: gradientShift 12s ease infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .welcome-content {
            position: relative;
            z-index: 1;
            text-align: center;
        }

        .welcome-title {
            font-size: 6rem;
            font-weight: 800;
            color: var(--text-primary);
            line-height: 1.1;
            text-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        /* Teams */
        #scene-teams {
            padding: 5rem 4rem 3rem;
            justify-content: flex-start;
        }

        .teams-display-grid {
            width: 100%;
            max-width: 1200px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
            overflow-y: auto;
            max-height: calc(100vh - 8rem);
            padding: 1rem 0;
            justify-content: center;
        }

        .teams-display-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            transition: all 0.4s ease;
        }

        .teams-display-card h3 {
            color: var(--accent);
            font-size: 1.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--border);
        }

        .teams-display-member {
            padding: 0.5rem 0;
            font-size: 1.25rem;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-light);
        }

        .teams-display-member:last-child {
            border-bottom: none;
        }

        .teams-display-count {
            margin-top: 0.75rem;
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        /* Scoreboard */
        #scene-scoreboard {
            padding: 5rem 4rem 3rem;
            justify-content: flex-start;
        }

        .scoreboard-list {
            width: 100%;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            overflow-y: auto;
            max-height: calc(100vh - 8rem);
            padding: 1rem 0;
        }

        .sb-row {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            padding: 1.25rem 2rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            transition: all 0.4s ease;
        }

        .sb-row.leader {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.08);
            transform: scale(1.03);
        }

        .sb-rank {
            font-size: 2.5rem;
            font-weight: 800;
            min-width: 3.5rem;
            text-align: center;
            color: var(--text-muted);
        }

        .sb-row.leader .sb-rank {
            color: #ffd700;
        }

        .sb-name {
            flex: 1;
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .sb-score {
            font-size: 3rem;
            font-weight: 800;
            color: var(--accent);
            font-variant-numeric: tabular-nums;
            min-width: 5rem;
            text-align: right;
        }

        .sb-row.leader .sb-score {
            color: #ffd700;
        }

        /* Timer */
        .timer-wrap {
            text-align: center;
        }

        .timer-mode-label {
            font-size: 1.5rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 1rem;
        }

        .timer-digits {
            font-size: 12rem;
            font-weight: 800;
            font-variant-numeric: tabular-nums;
            font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            color: var(--text-primary);
            line-height: 1;
            letter-spacing: 0.05em;
        }

        .timer-digits.danger {
            color: var(--error);
            animation: timerPulse 0.5s ease-in-out infinite alternate;
        }

        .timer-digits.warning {
            color: var(--warning);
        }

        @keyframes timerPulse {
            from { opacity: 1; }
            to { opacity: 0.3; }
        }

        /* Picker */
        .picker-wrap {
            text-align: center;
            z-index: 1;
        }

        .picker-label {
            font-size: 1.5rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 2rem;
        }

        .picker-window {
            width: 600px;
            max-width: 80vw;
            height: 8rem;
            overflow: hidden;
            position: relative;
            border: 3px solid var(--border);
            border-radius: var(--radius-lg);
            background: var(--bg-secondary);
            margin: 0 auto;
        }

        .picker-window::before,
        .picker-window::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 2.5rem;
            z-index: 2;
            pointer-events: none;
        }

        .picker-window::before {
            top: 0;
            background: linear-gradient(to bottom, var(--bg-secondary), transparent);
        }

        .picker-window::after {
            bottom: 0;
            background: linear-gradient(to top, var(--bg-secondary), transparent);
        }

        .picker-reel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: transform 0.08s linear;
        }

        .picker-reel-item {
            height: 8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: 700;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .picker-winner {
            margin-top: 2rem;
            font-size: 5rem;
            font-weight: 800;
            color: var(--success);
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .picker-winner.revealed {
            opacity: 1;
            transform: scale(1);
        }

        .picker-confetti {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .confetti-piece {
            position: absolute;
            width: 10px;
            height: 20px;
            top: -20px;
            animation: confettiFall linear forwards;
        }

        @keyframes confettiFall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
        }



        .sched-item {
            display: flex;
            align-items: flex-start;
            gap: 2rem;
            padding: 1.25rem 0;
            border-left: 4px solid var(--border);
            padding-left: 2rem;
            position: relative;
        }

        .sched-item::before {
            content: '';
            position: absolute;
            left: -9px;
            top: 1.5rem;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 3px solid var(--border);
        }

        .sched-item.current {
            border-left-color: var(--accent);
            background: var(--accent-subtle);
            margin-left: -1rem;
            padding-left: 3rem;
            border-radius: 0 var(--radius-lg) var(--radius-lg) 0;
        }

        .sched-item.current::before {
            background: var(--accent);
            border-color: var(--accent);
            box-shadow: 0 0 0 6px var(--accent-subtle);
        }

        .sched-item.past {
            opacity: 0.4;
        }

        .sched-item.past::before {
            background: var(--text-muted);
            border-color: var(--text-muted);
        }

        .sched-time {
            min-width: 100px;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-secondary);
        }

        .sched-item.current .sched-time {
            color: var(--accent);
        }

        .sched-details {
            flex: 1;
        }

        .sched-title {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .sched-item.current .sched-title {
            color: var(--accent);
        }

        .sched-meta {
            font-size: 1rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        .sched-now-badge {
            display: inline-block;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            background: var(--accent);
            color: #fff;
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            margin-left: 0.75rem;
            vertical-align: middle;
        }

        /* Message */
        .message-wrap {
            text-align: center;
            padding: 2rem;
            max-width: 90vw;
        }

        .message-text {
            font-size: 5rem;
            font-weight: 800;
            color: var(--text-primary);
            line-height: 1.2;
            word-break: break-word;
        }

        .message-subtitle {
            font-size: 2rem;
            color: var(--text-secondary);
            margin-top: 1rem;
        }

        /* Standby */
        .standby-content {
            text-align: center;
        }

        .standby-text {
            font-size: 1.5rem;
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .standby-dots {
            display: flex;
            gap: 6px;
            justify-content: center;
        }

        .standby-dots span {
            width: 8px;
            height: 8px;
            background: var(--text-muted);
            border-radius: 50%;
            animation: standbyPulse 1.4s infinite ease-in-out;
        }

        .standby-dots span:nth-child(2) { animation-delay: 0.2s; }
        .standby-dots span:nth-child(3) { animation-delay: 0.4s; }

        .fullscreen-btn {
            margin-top: 1.5rem;
            padding: 1rem 2.5rem;
            font-size: 1.25rem;
            font-weight: 600;
            border-radius: 8px;
            border: 2px solid var(--accent);
            background: var(--accent);
            color: #fff;
            cursor: pointer;
        }

        @keyframes standbyPulse {
            0%, 60%, 100% { opacity: 0.3; transform: scale(0.8); }
            30% { opacity: 1; transform: scale(1); }
        }

        /* Ambient */
        #scene-ambient {
            background: #000;
        }

        /* Camera */
        #scene-camera {
            background: #000;
        }

        .camera-video {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
        }

        .camera-status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: var(--text-muted);
            pointer-events: none;
        }

        .camera-video:not([srcObject]) + .camera-status,
        .camera-status.waiting {
            display: block;
        }

        /* Waiting */
        .waiting-wrap {
            text-align: center;
        }

        .waiting-label {
            font-size: 2rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 1rem;
        }

        .waiting-time {
            font-size: 10rem;
            font-weight: 800;
            font-variant-numeric: tabular-nums;
            font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            color: var(--text-primary);
            line-height: 1;
        }

        .waiting-sub {
            font-size: 1.5rem;
            color: var(--text-muted);
            margin-top: 1rem;
        }

        /* Attention flash */
        .attention-flash {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            opacity: 0;
            pointer-events: none;
            z-index: 100;
            transition: opacity 0.1s ease;
        }

        .attention-flash.active {
            animation: flashAnim 0.6s ease-out;
        }

        @keyframes flashAnim {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        /* Ambient scene animation helper styles */
        #scene-ambient { background: #000; }
        .ambient-gradient { animation: gradientShift 20s linear infinite; background-size: 400% 400%; }
        .blob { position:absolute;border-radius:50%;opacity:0.6;mix-blend-mode:screen;filter:blur(18px); }
        /* Slides */
        #scene-slides {
            padding: 0;
            background: #000;
        }

        .slides-counter {
            display: none;
        }

        .slides-content {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .slides-content img {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
        }

        .slides-content video {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
        }

        .slides-empty {
            font-size: 2rem;
            color: var(--text-muted);
        }
    </style>

    <script>
                // Add or subtract ms from countdown timer (only in countdown mode)
                function adjustCountdown(ms) {
                    if (timerMode !== 'countdown') return;
                    // Add to the remaining time, not the original set time
                    let remaining = Math.max(0, timerCountdownMs - timerElapsed);
                    remaining += ms;
                    if (remaining < 0) remaining = 0;
                    timerCountdownMs = timerElapsed + remaining;
                    updateTimerDisplay();
                }
        let currentScene = 'standby';
        let timerMode = 'stopwatch';
        let timerRunning = false;
        let timerStartTime = 0;
        let timerElapsed = 0;
        let timerCountdownMs = 0;
        let timerInterval = null;
        let pickerPool = [];
        let pickerSpinInterval = null;
        let pickerWinner = null;
        let waitingStartTime = null;
        let waitingInterval = null;
        let waitingAccumulated = 0;
        let slidesFiles = [];
        let slidesIndex = 0;
        let slidesLocalNav = false;
        let _pdfDoc = null;
        let _pdfPage = 0;
        let _pdfTotalPages = 0;
        let _preAmbientScene = null;
        let _displayPC = null;


        // Mobile reveal logic
        let _pendingScene = null;
        function isMobile() {
            return window.innerWidth <= 700 || /Mobi|Android/i.test(navigator.userAgent);
        }

        function init() {
            const eventName = localStorage.getItem('eventToolsEventName') || 'Event Suite';
            document.getElementById('welcomeTitle').textContent = eventName;
            if (isMobile()) {
                showScene('standby');
                document.getElementById('goFullscreenBtn').style.display = 'none';
                document.getElementById('revealSceneBtn').style.display = 'block';
                document.getElementById('revealSceneBtn').onclick = function() {
                    if (_pendingScene) {
                        showScene(_pendingScene);
                        _pendingScene = null;
                        document.getElementById('revealSceneBtn').style.display = 'none';
                    }
                };
            } else {
                showScene('standby');
            }

        }

        function goFullscreen() {
            var el = document.documentElement;
            var rfs = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
            if (rfs) rfs.call(el);
            document.getElementById('goFullscreenBtn').style.display = 'none';
        }

        // Auto re-enter fullscreen on any click (Escape from clicker exits it)
        document.addEventListener('click', function() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                goFullscreen();
            }
        });

        // Re-show button if fullscreen is exited (e.g. by clicker's Escape key)
        document.addEventListener('fullscreenchange', function() {
            if (!document.fullscreenElement) {
                document.getElementById('goFullscreenBtn').style.display = '';
            }
        });
        document.addEventListener('webkitfullscreenchange', function() {
            if (!document.webkitFullscreenElement) {
                document.getElementById('goFullscreenBtn').style.display = '';
            }
        });

        function showScene(scene) {
            if (isMobile() && scene !== 'standby' && !window._sceneRevealAllowed) {
                _pendingScene = scene;
                document.querySelectorAll('.scene').forEach(el => el.classList.remove('active'));
                document.getElementById('scene-standby').classList.add('active');
                document.getElementById('revealSceneBtn').style.display = 'block';
                return;
            }
            if (currentScene === 'waiting') stopWaiting();
            document.querySelectorAll('.scene').forEach(el => el.classList.remove('active'));
            const target = document.getElementById('scene-' + scene);
            if (target) {
                target.classList.add('active');
                currentScene = scene;
            }
            if (scene === 'waiting') startWaiting();
            if (scene === 'slides' && slidesFiles.length === 0) {
                fetch('/api/files').then(r => r.json()).then(files => {
                    if (files.length > 0) {
                        slidesFiles = files;
                        slidesIndex = 0;
                        loadSlide();
                    }
                }).catch(() => {});
            }
        }

        // Timer
        function formatTimerDisplay(ms) {
            const totalSeconds = Math.floor(Math.abs(ms) / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return String(hours).padStart(2, '0') + ':' +
                   String(minutes).padStart(2, '0') + ':' +
                   String(seconds).padStart(2, '0');
        }

        function updateTimerDisplay() {
            const el = document.getElementById('timerDigits');
            let displayMs;

            if (timerMode === 'stopwatch') {
                displayMs = timerElapsed;
                el.classList.remove('danger', 'warning');
            } else {
                displayMs = Math.max(0, timerCountdownMs - timerElapsed);
                el.classList.remove('danger', 'warning');
                if (displayMs <= 0) {
                    el.classList.add('danger');
                    if (timerRunning) {
                        stopTimer();
                        playAlarm();
                    }
                } else if (displayMs <= 10000) {
                    el.classList.add('danger');
                } else if (displayMs <= 30000) {
                    el.classList.add('warning');
                }
            }

            el.textContent = formatTimerDisplay(displayMs);
        }

        function timerTick() {
            timerElapsed = Date.now() - timerStartTime;
            updateTimerDisplay();
        }

        function startTimer() {
            if (timerRunning) return;
            timerRunning = true;
            timerStartTime = Date.now() - timerElapsed;
            timerInterval = setInterval(timerTick, 50);
        }

        function stopTimer() {
            timerRunning = false;
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function resetTimer() {
            stopTimer();
            timerElapsed = 0;
            const el = document.getElementById('timerDigits');
            el.classList.remove('danger', 'warning');
            updateTimerDisplay();
        }

        function playAlarm() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const freqs = [880, 1100, 880, 1100, 880, 1100];
                freqs.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.value = freq;
                        osc.type = 'square';
                        gain.gain.setValueAtTime(0.5, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.2);
                    }, i * 250);
                });
            } catch (e) {}
        }

        // Teams
        function renderTeams(teamsData) {
            const grid = document.getElementById('teamsGrid');
            if (!teamsData || teamsData.length === 0) {
                grid.innerHTML = '<div style="text-align:center;color:var(--text-muted);font-size:2rem;grid-column:1/-1;">No teams yet</div>';
                return;
            }
            grid.innerHTML = teamsData.map(team =>
                '<div class="teams-display-card">' +
                '<h3>' + escapeHtml(team.name) + '</h3>' +
                team.members.map(m => '<div class="teams-display-member">' + escapeHtml(m) + '</div>').join('') +
                '<div class="teams-display-count">' + team.members.length + ' members</div>' +
                '</div>'
            ).join('');
        }

        // Scoreboard
        function renderScoreboard() {
            const saved = localStorage.getItem('eventToolsScoring');
            const list = document.getElementById('scoreboardList');
            if (!saved) {
                list.innerHTML = '<div style="text-align:center;color:var(--text-muted);font-size:2rem;">No scores yet</div>';
                return;
            }

            const data = JSON.parse(saved);
            const teams = data.teams || [];
            const sorted = teams.map(t => ({
                name: t.name,
                score: t.scores.reduce((a, b) => a + b, 0)
            })).sort((a, b) => b.score - a.score);

            const maxScore = sorted.length > 0 ? sorted[0].score : 0;

            list.innerHTML = sorted.map((team, i) => {
                const isLeader = team.score === maxScore && team.score > 0;
                return `<div class="sb-row ${isLeader ? 'leader' : ''}">
                    <div class="sb-rank">${i + 1}</div>
                    <div class="sb-name">${escapeHtml(team.name)}</div>
                    <div class="sb-score">${team.score}</div>
                </div>`;
            }).join('');
        }

        // schedule removed

        // Picker
        function startPicker(pool) {
            pickerPool = pool;
            pickerWinner = null;
            const winnerEl = document.getElementById('pickerWinner');
            winnerEl.classList.remove('revealed');
            winnerEl.textContent = '';
            document.getElementById('pickerConfetti').innerHTML = '';

            const reel = document.getElementById('pickerReel');

            if (pickerSpinInterval) clearInterval(pickerSpinInterval);

            pickerSpinInterval = setInterval(() => {
                const idx = Math.floor(Math.random() * pickerPool.length);
                reel.innerHTML = '<div class="picker-reel-item">' + escapeHtml(pickerPool[idx]) + '</div>';
            }, 80);
        }

        function revealPicker() {
            if (pickerSpinInterval) {
                clearInterval(pickerSpinInterval);
                pickerSpinInterval = null;
            }

            if (pickerPool.length === 0) return;

            const winnerIdx = Math.floor(Math.random() * pickerPool.length);
            pickerWinner = pickerPool[winnerIdx];

            const reel = document.getElementById('pickerReel');
            reel.innerHTML = '<div class="picker-reel-item">' + escapeHtml(pickerWinner) + '</div>';

            const winnerEl = document.getElementById('pickerWinner');
            winnerEl.textContent = pickerWinner;
            setTimeout(() => winnerEl.classList.add('revealed'), 50);

            spawnConfetti();
            playWinSound();
        }

        function spawnConfetti() {
            const container = document.getElementById('pickerConfetti');
            container.innerHTML = '';
            const colors = ['#ffd700', '#ff6b6b', '#58a6ff', '#3fb950', '#f0883e', '#d2a8ff'];
            for (let i = 0; i < 80; i++) {
                const piece = document.createElement('div');
                piece.className = 'confetti-piece';
                piece.style.left = Math.random() * 100 + 'vw';
                piece.style.background = colors[Math.floor(Math.random() * colors.length)];
                piece.style.animationDuration = (2 + Math.random() * 2) + 's';
                piece.style.animationDelay = Math.random() * 0.5 + 's';
                piece.style.width = (6 + Math.random() * 8) + 'px';
                piece.style.height = (10 + Math.random() * 15) + 'px';
                piece.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
                container.appendChild(piece);
            }
            setTimeout(() => container.innerHTML = '', 5000);
        }

        // Ambient scene animations
        let _ambientMode = null;
        let _ambientAnimation = null;
        let _ambientCanvas, _ambientCtx, _ambientW, _ambientH;

        function setAmbientMode(mode, text) {
            _ambientMode = mode;
            const canvas = document.getElementById('ambientCanvas');
            const overlayLogo = document.getElementById('ambientLogo');
            const overlayText = document.getElementById('ambientText');
            if (!canvas) return;
            canvas.width = canvas.clientWidth * devicePixelRatio;
            canvas.height = canvas.clientHeight * devicePixelRatio;
            _ambientCanvas = canvas; _ambientCtx = canvas.getContext('2d');
            _ambientW = canvas.width; _ambientH = canvas.height;
            overlayLogo.style.display = 'none';
            cancelAmbient();
            // overlay text
            if (text) {
                overlayText.textContent = text;
                overlayText.style.display = 'block';
            } else {
                overlayText.style.display = 'none';
            }
            switch (mode) {
                case 'starfield': startStarfield(); break;
                case 'gradient': startGradientWave(); break;
                case 'bouncing': startBouncingLogo(); break;
                case 'matrix': startMatrixRain(); break;
                case 'blobs': startAmbientBlobs(); break;
                case 'campfire': startCampfire(); break;
                case 'geometric': startGeometricWaves(); break;
                case 'lava': startLavaLamp(); break;
                default: cancelAmbient(); break;
            }
        }

        function cancelAmbient() {
            if (_ambientAnimation && _ambientAnimation.stop) try { _ambientAnimation.stop(); } catch (e) {}
            _ambientAnimation = null;
            const ctx = _ambientCtx;
            if (ctx) ctx.clearRect(0,0,_ambientW,_ambientH);
            document.getElementById('scene-ambient').style.background = '';
            document.getElementById('ambientLogo').style.display = 'none';
            document.querySelectorAll('#ambientContainer .blob').forEach(b => b.remove());
        }

        function clearAmbient() { cancelAmbient(); }

        // Starfield — use pixel positions and speeds
        function startStarfield() {
            const count = Math.max(100, Math.floor((_ambientW/_ambientH) * 120));
            const stars = Array.from({length:count}, () => ({
                x: Math.random() * _ambientW,
                y: Math.random() * _ambientH,
                z: 0.2 + Math.random() * 2.8,
                vx: (Math.random()-0.5) * 0.2,
                vy: 0.05 + Math.random() * 0.4
            }));
            let raf;
            function draw() {
                const ctx = _ambientCtx; ctx.clearRect(0,0,_ambientW,_ambientH);
                for (let s of stars) {
                    s.y += s.vy * s.z;
                    s.x += s.vx * s.z;
                    if (s.y > _ambientH + 10) { s.y = -10; s.x = Math.random() * _ambientW; }
                    if (s.x < -10) s.x = _ambientW + 10;
                    if (s.x > _ambientW + 10) s.x = -10;
                    const r = Math.max(0.6, s.z * 0.6) * devicePixelRatio;
                    ctx.globalAlpha = Math.min(1, 0.4 + s.z / 3);
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(s.x, s.y, r, 0, Math.PI*2); ctx.fill();
                }
                raf = requestAnimationFrame(draw);
            }
            _ambientAnimation = { stop: () => cancelAnimationFrame(raf) };
            draw();
        }

        // Gradient — smoothly drifting color pools on canvas
        function startGradientWave() {
            const ctx = _ambientCtx;
            const W = _ambientW, H = _ambientH;
            const spots = [
                { hue: 210, sat: 80, lum: 25, x: 0.2, y: 0.3, r: 0.5, sx: 0.0003, sy: 0.0005, px: 0, py: 0 },
                { hue: 270, sat: 60, lum: 20, x: 0.7, y: 0.2, r: 0.45, sx: 0.0004, sy: 0.0003, px: 1.5, py: 2.0 },
                { hue: 320, sat: 50, lum: 18, x: 0.5, y: 0.8, r: 0.55, sx: 0.0002, sy: 0.0006, px: 3.0, py: 0.5 },
                { hue: 180, sat: 70, lum: 22, x: 0.8, y: 0.7, r: 0.4, sx: 0.0005, sy: 0.0002, px: 4.5, py: 3.5 },
                { hue: 150, sat: 50, lum: 15, x: 0.3, y: 0.6, r: 0.5, sx: 0.0003, sy: 0.0004, px: 2.0, py: 5.0 },
            ];
            let raf, t = 0;
            function draw() {
                // dark base
                ctx.fillStyle = '#080810';
                ctx.fillRect(0, 0, W, H);

                for (const s of spots) {
                    const cx = (s.x + Math.sin(t * s.sx + s.px) * 0.3) * W;
                    const cy = (s.y + Math.cos(t * s.sy + s.py) * 0.3) * H;
                    const radius = s.r * Math.max(W, H);
                    // hue drifts slowly
                    const hue = s.hue + Math.sin(t * 0.0002 + s.px) * 30;
                    const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
                    grd.addColorStop(0, `hsla(${hue},${s.sat}%,${s.lum}%,0.6)`);
                    grd.addColorStop(0.4, `hsla(${hue},${s.sat}%,${s.lum * 0.7}%,0.3)`);
                    grd.addColorStop(1, 'hsla(0,0%,0%,0)');
                    ctx.fillStyle = grd;
                    ctx.fillRect(0, 0, W, H);
                }

                // subtle noise-like texture via small random dots (sparse, not every pixel)
                ctx.globalAlpha = 0.015;
                ctx.fillStyle = '#fff';
                for (let i = 0; i < 60; i++) {
                    const nx = Math.random() * W, ny = Math.random() * H;
                    ctx.fillRect(nx, ny, 2 * devicePixelRatio, 2 * devicePixelRatio);
                }
                ctx.globalAlpha = 1;

                t++;
                raf = requestAnimationFrame(draw);
            }
            _ambientAnimation = { stop: () => cancelAnimationFrame(raf) };
            draw();
        }

        // Bouncing logo — pixel-based, slower, keeps inside bounds
        function startBouncingLogo() {
            const logo = document.getElementById('ambientLogo');
            const container = document.getElementById('ambientContainer');
            logo.style.display = 'block';
            // initialize sizes on next frame to ensure layout metrics are correct
            let x = 0, y = 0, dx = 2, dy = 2, raf;
            const resizeHandler = () => {
                const crect = container.getBoundingClientRect();
                const lrect = logo.getBoundingClientRect();
                // ensure logo remains inside bounds after resize
                if (x + lrect.width > crect.width) x = Math.max(0, crect.width - lrect.width);
                if (y + lrect.height > crect.height) y = Math.max(0, crect.height - lrect.height);
            };

            function stepInit() {
                // ensure logo participates as an absolutely positioned element inside container
                logo.style.position = 'absolute';
                logo.style.left = '0';
                logo.style.top = '0';
                logo.style.margin = '0';
                logo.style.transform = 'none';
                // force reflow
                void logo.offsetWidth;

                const w = container.clientWidth;
                const h = container.clientHeight;
                const lW = logo.offsetWidth;
                const lH = logo.offsetHeight;
                // center initial position using CSS pixels
                x = (w - lW) / 2;
                y = (h - lH) / 2;
                // speed scaled to container size (CSS pixels)
                dx = Math.max(1, w * 0.002);
                dy = Math.max(1, h * 0.002);

                function step() {
                    const cw = container.clientWidth;
                    const ch = container.clientHeight;
                    const curLW = logo.offsetWidth;
                    const curLH = logo.offsetHeight;
                    x += dx; y += dy;
                    if (x <= 0) { x = 0; dx = Math.abs(dx); }
                    if (x + curLW >= cw) { x = cw - curLW; dx = -Math.abs(dx); }
                    if (y <= 0) { y = 0; dy = Math.abs(dy); }
                    if (y + curLH >= ch) { y = ch - curLH; dy = -Math.abs(dy); }
                    logo.style.transform = `translate3d(${x}px, ${y}px, 0)`;
                    raf = requestAnimationFrame(step);
                }

                window.addEventListener('resize', resizeHandler);
                _ambientAnimation = { stop: () => { cancelAnimationFrame(raf); window.removeEventListener('resize', resizeHandler); } };
                step();
            }

            // wait a frame so styles/layout settle (ensures correct bounding rects)
            requestAnimationFrame(stepInit);
        }

        // Matrix rain
        function startMatrixRain() {
            const ctx = _ambientCtx;
            const cols = Math.floor(_ambientW / 14);
            const drops = new Array(cols).fill(1);
            let raf;
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            function draw() {
                ctx.fillStyle = 'rgba(0,0,0,0.15)';
                ctx.fillRect(0,0,_ambientW,_ambientH);
                ctx.fillStyle = '#0f0'; ctx.font = (12*devicePixelRatio)+'px monospace';
                for (let i=0;i<cols;i++) {
                    const text = String.fromCharCode(0x30A0 + Math.random()*96);
                    ctx.fillText(text, i*14*devicePixelRatio, drops[i]*14*devicePixelRatio);
                    if (drops[i]*14*devicePixelRatio > _ambientH && Math.random() > 0.975) drops[i]=0;
                    drops[i]++;
                }
                raf = requestAnimationFrame(draw);
            }
            _ambientAnimation = { stop: () => cancelAnimationFrame(raf) };
            draw();
        }

        // Ambient blobs
        function startAmbientBlobs() {
            const container = document.getElementById('ambientContainer');
            const colors = ['#58a6ff', '#a371f7', '#3fb950', '#f0883e', '#db61a2', '#f78166'];
            const blobs = [];
            for (let i = 0; i < 6; i++) {
                const blob = document.createElement('div');
                blob.className = 'blob';
                const size = 150 + Math.random() * 200;
                blob.style.width = size + 'px';
                blob.style.height = size + 'px';
                blob.style.background = colors[i % colors.length];
                blob.style.left = Math.random() * 100 + '%';
                blob.style.top = Math.random() * 100 + '%';
                container.appendChild(blob);
                blobs.push({
                    el: blob, x: Math.random() * container.clientWidth,
                    y: Math.random() * container.clientHeight,
                    vx: (Math.random() - 0.5) * 0.8, vy: (Math.random() - 0.5) * 0.8, size: size
                });
            }
            let raf;
            function step() {
                const cw = container.clientWidth, ch = container.clientHeight;
                for (const b of blobs) {
                    b.x += b.vx; b.y += b.vy;
                    if (b.x < -b.size / 2 || b.x > cw + b.size / 2) b.vx *= -1;
                    if (b.y < -b.size / 2 || b.y > ch + b.size / 2) b.vy *= -1;
                    b.el.style.transform = `translate(${b.x}px, ${b.y}px)`;
                }
                raf = requestAnimationFrame(step);
            }
            _ambientAnimation = { stop: () => { cancelAnimationFrame(raf); blobs.forEach(b => b.el.remove()); } };
            step();
        }

        // Campfire embers — warm particles drifting up with a flickering fire glow
        function startCampfire() {
            const ctx = _ambientCtx;
            const W = _ambientW, H = _ambientH;
            const dpr = devicePixelRatio;
            const embers = [];
            for (let i = 0; i < 200; i++) resetEmber(embers[i] = {}, true);

            function resetEmber(e, scatter) {
                const spread = 0.5;
                e.x = W * (0.5 - spread/2) + Math.random() * W * spread;
                e.y = scatter ? Math.random() * H : H + Math.random() * 40;
                e.vx = (Math.random() - 0.5) * 0.8;
                e.vy = -(0.6 + Math.random() * 2.0);
                e.size = (1.5 + Math.random() * 3) * dpr;
                e.life = 1;
                e.maxLife = 1;
                e.decay = 0.003 + Math.random() * 0.006;
                e.wobbleSpeed = 1 + Math.random() * 3;
                e.wobbleAmp = 0.3 + Math.random() * 0.8;
                e.t = Math.random() * 100;
            }

            let raf, t = 0;
            function draw() {
                ctx.clearRect(0, 0, W, H);
                // dark warm background
                ctx.fillStyle = '#0a0604';
                ctx.fillRect(0, 0, W, H);

                // large soft fire glow at bottom center
                const flicker = 0.85 + Math.sin(t * 0.07) * 0.08 + Math.sin(t * 0.13) * 0.07;
                const glowR = H * 0.55 * flicker;
                const grd = ctx.createRadialGradient(W/2, H * 1.05, 0, W/2, H * 1.05, glowR);
                grd.addColorStop(0, `rgba(255,100,20,${0.35 * flicker})`);
                grd.addColorStop(0.3, `rgba(255,60,10,${0.15 * flicker})`);
                grd.addColorStop(0.6, `rgba(180,30,5,${0.06 * flicker})`);
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, W, H);

                // second glow, slightly offset for flicker
                const grd2 = ctx.createRadialGradient(W/2 + Math.sin(t*0.05)*20, H*1.02, 0, W/2, H*1.02, glowR*0.7);
                grd2.addColorStop(0, `rgba(255,180,50,${0.12 * flicker})`);
                grd2.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd2;
                ctx.fillRect(0, 0, W, H);

                // embers
                for (const e of embers) {
                    e.t += 0.016;
                    e.x += e.vx + Math.sin(e.t * e.wobbleSpeed) * e.wobbleAmp;
                    e.y += e.vy;
                    e.vy *= 0.999; // slow down slightly as they rise
                    e.life -= e.decay;
                    if (e.life <= 0) { resetEmber(e, false); continue; }

                    const progress = 1 - e.life;
                    const alpha = e.life * (progress < 0.1 ? progress / 0.1 : 1);
                    const r = e.size * (0.3 + e.life * 0.7);

                    // warm color: bright yellow-white at start → orange → deep red at end
                    const temp = e.life;
                    const red = 255;
                    const green = Math.floor(80 + temp * 170);
                    const blue = Math.floor(temp * temp * 80);

                    ctx.globalAlpha = alpha * 0.9;
                    ctx.fillStyle = `rgb(${red},${green},${blue})`;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
                    ctx.fill();

                    // soft glow around each ember
                    ctx.globalAlpha = alpha * 0.3;
                    const eg = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, r * 4);
                    eg.addColorStop(0, `rgba(${red},${green},${blue},0.4)`);
                    eg.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = eg;
                    ctx.fillRect(e.x - r*4, e.y - r*4, r*8, r*8);
                }
                ctx.globalAlpha = 1;
                t++;
                raf = requestAnimationFrame(draw);
            }
            _ambientAnimation = { stop: () => cancelAnimationFrame(raf) };
            draw();
        }

        // Geometric waves — layered sine waves with clean lines
        function startGeometricWaves() {
            const ctx = _ambientCtx;
            const W = _ambientW, H = _ambientH;
            const dpr = devicePixelRatio;
            const layers = [];
            const layerCount = 12;
            for (let i = 0; i < layerCount; i++) {
                layers.push({
                    yBase: H * (0.2 + (i / layerCount) * 0.6),
                    amplitude: 20 + i * 8,
                    freq: 0.0015 + i * 0.0003,
                    speed: 0.008 + i * 0.002,
                    phase: i * 0.8,
                    hue: 200 + i * 12,
                    thickness: (2 + i * 0.3) * dpr
                });
            }
            let raf, t = 0;
            function draw() {
                ctx.clearRect(0, 0, W, H);
                // dark blue-black background
                const bg = ctx.createLinearGradient(0, 0, 0, H);
                bg.addColorStop(0, '#050510');
                bg.addColorStop(1, '#0a0a20');
                ctx.fillStyle = bg;
                ctx.fillRect(0, 0, W, H);

                for (let li = 0; li < layers.length; li++) {
                    const l = layers[li];
                    const depthAlpha = 0.15 + (li / layers.length) * 0.5;

                    // filled shape below the wave for soft glow
                    ctx.beginPath();
                    for (let x = 0; x <= W; x += 3) {
                        const wave = Math.sin(x * l.freq + t * l.speed + l.phase) * l.amplitude
                            + Math.sin(x * l.freq * 2.3 + t * l.speed * 0.7 + l.phase * 1.5) * l.amplitude * 0.3;
                        const y = l.yBase + wave;
                        if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    ctx.lineTo(W, H);
                    ctx.lineTo(0, H);
                    ctx.closePath();
                    ctx.fillStyle = `hsla(${l.hue + Math.sin(t * 0.003) * 20},60%,50%,${depthAlpha * 0.08})`;
                    ctx.fill();

                    // the wave line itself
                    ctx.beginPath();
                    for (let x = 0; x <= W; x += 3) {
                        const wave = Math.sin(x * l.freq + t * l.speed + l.phase) * l.amplitude
                            + Math.sin(x * l.freq * 2.3 + t * l.speed * 0.7 + l.phase * 1.5) * l.amplitude * 0.3;
                        const y = l.yBase + wave;
                        if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    ctx.strokeStyle = `hsla(${l.hue + Math.sin(t * 0.003) * 20},70%,65%,${depthAlpha})`;
                    ctx.lineWidth = l.thickness;
                    ctx.stroke();

                    // glow line on top
                    ctx.strokeStyle = `hsla(${l.hue + Math.sin(t * 0.003) * 20},80%,80%,${depthAlpha * 0.4})`;
                    ctx.lineWidth = l.thickness * 0.4;
                    ctx.stroke();
                }
                t++;
                raf = requestAnimationFrame(draw);
            }
            _ambientAnimation = { stop: () => cancelAnimationFrame(raf) };
            draw();
        }

        // Lava lamp — smooth metaballs with gradient color blending
        function startLavaLamp() {
            const ctx = _ambientCtx;
            const W = _ambientW, H = _ambientH;
            const scale = 3;
            const sw = Math.ceil(W / scale), sh = Math.ceil(H / scale);
            const balls = [];
            const count = 6;
            const palette = [
                { r: 220, g: 30, b: 70 },
                { r: 255, g: 90, b: 20 },
                { r: 180, g: 40, b: 200 },
                { r: 80, g: 20, b: 220 },
                { r: 240, g: 60, b: 120 },
                { r: 200, g: 50, b: 180 },
            ];
            for (let i = 0; i < count; i++) {
                balls.push({
                    x: Math.random() * W, y: Math.random() * H,
                    vx: (Math.random() - 0.5) * 0.6,
                    vy: -0.3 + Math.random() * 0.6,
                    r: (80 + Math.random() * 100) * (W / 1920 + 0.5),
                    color: palette[i % palette.length],
                    phase: Math.random() * Math.PI * 2
                });
            }
            const offscreen = new OffscreenCanvas(sw, sh);
            const octx = offscreen.getContext('2d');
            const imgData = octx.createImageData(sw, sh);
            let raf, t = 0;

            function draw() {
                t += 0.01;
                for (const b of balls) {
                    b.x += b.vx + Math.sin(t + b.phase) * 0.3;
                    b.y += b.vy + Math.cos(t * 0.7 + b.phase) * 0.2;
                    // buoyancy: rise when low, sink when high
                    b.vy += (H * 0.5 - b.y) * 0.00002;
                    b.vx += (W * 0.5 - b.x) * 0.00001;
                    // damping
                    b.vx *= 0.999; b.vy *= 0.999;
                    // soft bounds
                    if (b.x < b.r * 0.5) b.vx += 0.05;
                    if (b.x > W - b.r * 0.5) b.vx -= 0.05;
                    if (b.y < b.r * 0.5) b.vy += 0.05;
                    if (b.y > H - b.r * 0.5) b.vy -= 0.05;
                }

                const d = imgData.data;
                for (let y = 0; y < sh; y++) {
                    for (let x = 0; x < sw; x++) {
                        const px = x * scale, py = y * scale;
                        let sumR = 0, sumG = 0, sumB = 0, sumW = 0;
                        for (const b of balls) {
                            const dx = px - b.x, dy = py - b.y;
                            const dist2 = dx * dx + dy * dy + 1;
                            const influence = (b.r * b.r) / dist2;
                            sumR += b.color.r * influence;
                            sumG += b.color.g * influence;
                            sumB += b.color.b * influence;
                            sumW += influence;
                        }
                        const idx = (y * sw + x) * 4;
                        if (sumW > 1.0) {
                            // smooth threshold with soft edge
                            const edge = Math.min(1, (sumW - 1.0) * 2.5);
                            const bright = 0.5 + edge * 0.5;
                            d[idx]     = Math.min(255, (sumR / sumW) * bright);
                            d[idx + 1] = Math.min(255, (sumG / sumW) * bright);
                            d[idx + 2] = Math.min(255, (sumB / sumW) * bright);
                            d[idx + 3] = Math.floor(180 + edge * 75);
                        } else {
                            // background — very dark with a slight warm tint
                            const bg = sumW * 0.15;
                            d[idx] = Math.floor(15 + bg * 40);
                            d[idx+1] = Math.floor(5 + bg * 10);
                            d[idx+2] = Math.floor(20 + bg * 30);
                            d[idx+3] = 255;
                        }
                    }
                }
                octx.putImageData(imgData, 0, 0);
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(offscreen, 0, 0, W, H);
                raf = requestAnimationFrame(draw);
            }
            _ambientAnimation = { stop: () => cancelAnimationFrame(raf) };
            draw();
        }

        function playWinSound() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                [0, 100, 200].forEach((delay, i) => {
                    setTimeout(() => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.value = 600 + (i * 200);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.3, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.15);
                    }, delay);
                });
            } catch (e) {}
        }

        function playAttentionSound() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                [0, 150, 300].forEach((delay, i) => {
                    setTimeout(() => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.value = 800;
                        osc.type = 'triangle';
                        gain.gain.setValueAtTime(0.4, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.12);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.12);
                    }, delay);
                });
            } catch (e) {}
        }

        function flashAttention() {
                // Create a temporary overlay so flashes can't be cancelled by other DOM updates
                const temp = document.createElement('div');
                temp.className = 'attention-flash';
                // ensure it sits above everything
                temp.style.zIndex = 9999;
                document.body.appendChild(temp);
                // trigger animation
                void temp.offsetHeight;
                temp.classList.add('active');
                setTimeout(() => {
                    temp.classList.remove('active');
                    // remove after animation completes
                    setTimeout(() => temp.remove(), 300);
                }, 700);
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Waiting timer
        function startWaiting() {
            waitingStartTime = Date.now();
            if (waitingInterval) clearInterval(waitingInterval);
            waitingInterval = setInterval(updateWaiting, 1000);
            updateWaiting();
        }

        function stopWaiting() {
            if (waitingInterval) {
                clearInterval(waitingInterval);
                waitingInterval = null;
            }
            if (waitingStartTime) {
                waitingAccumulated += Date.now() - waitingStartTime;
                waitingStartTime = null;
            }
        }

        function resetWaiting() {
            stopWaiting();
            waitingAccumulated = 0;
            document.getElementById('waitingTime').textContent = '00:00';
            document.getElementById('waitingSub').textContent = '';
        }

        function updateWaiting() {
            if (!waitingStartTime) return;
            const elapsed = waitingAccumulated + (Date.now() - waitingStartTime);
            const totalSec = Math.floor(elapsed / 1000);
            const min = Math.floor(totalSec / 60);
            const sec = totalSec % 60;
            document.getElementById('waitingTime').textContent =
                String(min).padStart(2, '0') + ':' + String(sec).padStart(2, '0');

            const subs = [
                "Still waiting...",
                "Any day now...",
                "Getting comfy?",
                "Time is a social construct",
                "Loading enthusiasm...",
                "Buffering...",
                "Are we there yet?",
                "Patience is a virtue",
                "Just a few more seconds...",
                "Definitely not forgotten",
                "This is fine.",
                "Elevator music plays...",
            ];
            const subEl = document.getElementById('waitingSub');
            if (totalSec > 0 && totalSec % 10 === 0) {
                subEl.textContent = subs[Math.floor(Math.random() * subs.length)];
            }
            if (totalSec === 1) {
                subEl.textContent = subs[0];
            }
        }

        function loadSlide() {
            const content = document.getElementById('slidesContent');
            const counter = document.getElementById('slidesCounter');

            _pdfDoc = null;
            _pdfPage = 0;
            _pdfTotalPages = 0;

            if (slidesFiles.length === 0) {
                content.innerHTML = '<div class="slides-empty">No slides loaded</div>';
                counter.textContent = '';
                return;
            }

            const file = slidesFiles[slidesIndex];
            counter.textContent = (slidesIndex + 1) + ' / ' + slidesFiles.length;

            if (file.type === 'image') {
                content.innerHTML = '<img src="' + file.path + '" alt="' + escapeHtml(file.name) + '">';
            } else if (file.type === 'video') {
                content.innerHTML = '<video src="' + file.path + '" id="slideVideo" autoplay></video>';
            } else if (file.type === 'pdf') {
                content.innerHTML = '<canvas id="pdfCanvas" style="max-width:100vw;max-height:100vh;object-fit:contain;"></canvas>';
                loadPdf(file.path);
            } else {
                content.innerHTML = '<div class="slides-empty">' + escapeHtml(file.name) + '</div>';
            }
        }

        function loadPdf(url) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'assets/pdf.worker.min.js';
            pdfjsLib.getDocument(url).promise.then(function(pdf) {
                _pdfDoc = pdf;
                _pdfTotalPages = pdf.numPages;
                _pdfPage = 1;
                renderPdfPage();
                sendCommand('pdf-page-update', { page: _pdfPage, total: _pdfTotalPages, fileIndex: slidesIndex });
            });
        }

        function renderPdfPage() {
            if (!_pdfDoc) return;
            _pdfDoc.getPage(_pdfPage).then(function(page) {
                var canvas = document.getElementById('pdfCanvas');
                if (!canvas) return;
                var ctx = canvas.getContext('2d');
                // Scale to fill viewport
                var vw = window.innerWidth;
                var vh = window.innerHeight;
                var unscaled = page.getViewport({ scale: 1 });
                var scale = Math.min(vw / unscaled.width, vh / unscaled.height);
                var viewport = page.getViewport({ scale: scale * devicePixelRatio });
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                canvas.style.width = (viewport.width / devicePixelRatio) + 'px';
                canvas.style.height = (viewport.height / devicePixelRatio) + 'px';
                page.render({ canvasContext: ctx, viewport: viewport });
            });
        }

        // Camera WebRTC (display = receiver)
        function handleCameraOffer(offer) {
            if (_displayPC) { _displayPC.close(); _displayPC = null; }

            _displayPC = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });

            _displayPC.ontrack = function(ev) {
                var video = document.getElementById('cameraVideo');
                video.srcObject = ev.streams[0];
                document.getElementById('cameraStatus').style.display = 'none';
            };

            _displayPC.onicecandidate = function(ev) {
                if (ev.candidate) {
                    sendCommand('camera-ice-candidate-display', { candidate: ev.candidate });
                }
            };

            _displayPC.onconnectionstatechange = function() {
                if (_displayPC.connectionState === 'disconnected' || _displayPC.connectionState === 'failed') {
                    document.getElementById('cameraStatus').style.display = '';
                    document.getElementById('cameraStatus').textContent = 'Camera disconnected';
                }
            };

            _displayPC.setRemoteDescription(new RTCSessionDescription(offer))
                .then(function() { return _displayPC.createAnswer(); })
                .then(function(answer) { return _displayPC.setLocalDescription(answer); })
                .then(function() {
                    sendCommand('camera-answer', { answer: _displayPC.localDescription });
                });
        }

        // Command handler
        onCommand(function(type, data) {
            switch (type) {
                case 'show-scene':
                    showScene(data.scene);
                    if (data.scene === 'scoreboard') renderScoreboard();
                    if (data.scene === 'teams') {
                        var saved = localStorage.getItem('eventToolsTeams');
                        renderTeams(saved ? JSON.parse(saved) : []);
                    }
                    break;

                case 'show-teams':
                    renderTeams(data.teams || []);
                    showScene('teams');
                    break;

                case 'refresh-teams':
                    var t = localStorage.getItem('eventToolsTeams');
                    renderTeams(t ? JSON.parse(t) : []);
                    break;

                case 'timer-start':
                    startTimer();
                    break;

                case 'timer-stop':
                    stopTimer();
                    break;

                case 'timer-reset':
                    resetTimer();
                    break;

                case 'timer-set':
                    if (data.ms) {
                        timerCountdownMs = data.ms;
                    } else {
                        const h = data.hours || 0;
                        const m = data.minutes || 0;
                        const s = data.seconds || 0;
                        timerCountdownMs = (h * 3600 + m * 60 + s) * 1000;
                    }
                    timerElapsed = 0;
                    updateTimerDisplay();
                    break;

                case 'timer-mode':
                    timerMode = data.mode || 'stopwatch';
                    document.getElementById('timerModeLabel').textContent =
                        timerMode === 'countdown' ? 'Countdown' : 'Stopwatch';
                    resetTimer();
                    break;

                case 'pick-start':
                    startPicker(data.pool || []);
                    break;

                case 'pick-reveal':
                    revealPicker();
                    break;

                case 'show-message':
                    document.getElementById('messageText').textContent = data.text || '';
                    document.getElementById('messageSubtitle').textContent = data.subtitle || '';
                    showScene('message');
                    break;

                case 'refresh-scores':
                    renderScoreboard();
                    break;

                // schedule removed

                case 'play-attention':
                    playAttentionSound();
                    flashAttention();
                    break;

                case 'waiting-reset':
                    resetWaiting();
                    break;

                case 'set-event-name':
                    if (data.name) {
                        localStorage.setItem('eventToolsEventName', data.name);
                        document.getElementById('welcomeTitle').textContent = data.name;
                    }
                    break;

                case 'set-theme':
                    var themes = {
                        light: {
                            '--bg-primary': '#ffffff', '--bg-secondary': '#f6f8fa', '--bg-tertiary': '#eaeef2',
                            '--text-primary': '#1f2328', '--text-secondary': '#656d76', '--text-muted': '#8b949e',
                            '--border': '#d0d7de', '--border-light': '#eaeef2'
                        },
                        mocha: {
                            '--bg-primary': '#1e1e2e', '--bg-secondary': '#181825', '--bg-tertiary': '#313244',
                            '--text-primary': '#cdd6f4', '--text-secondary': '#a6adc8', '--text-muted': '#6c7086',
                            '--border': '#45475a', '--border-light': '#313244',
                            '--accent': '#cba6f7', '--accent-hover': '#b4befe', '--accent-subtle': 'rgba(203,166,247,0.15)',
                            '--success': '#a6e3a1', '--warning': '#f9e2af', '--error': '#f38ba8'
                        },
                        dark: {
                            '--bg-primary': '#0d1117', '--bg-secondary': '#161b22', '--bg-tertiary': '#21262d',
                            '--text-primary': '#e6edf3', '--text-secondary': '#8b949e', '--text-muted': '#6e7681',
                            '--border': '#30363d', '--border-light': '#21262d'
                        }
                    };
                    var t = themes[data.theme] || themes.dark;
                    Object.keys(t).forEach(function(k) {
                        document.documentElement.style.setProperty(k, t[k]);
                    });
                    break;

                case 'set-accent':
                    document.documentElement.style.setProperty('--accent', data.color);
                    break;

                case 'set-font-size':
                    const sizes = { small: '14px', medium: '16px', large: '18px' };
                    document.documentElement.style.setProperty('--base-font-size', sizes[data.size] || '16px');
                    break;

                case 'slides-load':
                    slidesFiles = data.files || [];
                    slidesIndex = 0;
                    loadSlide();
                    break;

                case 'slides-goto':
                    slidesIndex = data.index || 0;
                    if (slidesIndex < 0) slidesIndex = 0;
                    if (slidesIndex >= slidesFiles.length) slidesIndex = slidesFiles.length - 1;
                    loadSlide();
                    break;

                case 'slides-next':
                    if (slidesLocalNav) { slidesLocalNav = false; break; }
                    if (_pdfDoc && _pdfPage < _pdfTotalPages) {
                        _pdfPage++;
                        renderPdfPage();
                        sendCommand('pdf-page-update', { page: _pdfPage, total: _pdfTotalPages, fileIndex: slidesIndex });
                    } else if (slidesIndex < slidesFiles.length - 1) {
                        slidesIndex++;
                        loadSlide();
                    }
                    break;

                case 'slides-prev':
                    if (slidesLocalNav) { slidesLocalNav = false; break; }
                    if (_pdfDoc && _pdfPage > 1) {
                        _pdfPage--;
                        renderPdfPage();
                        sendCommand('pdf-page-update', { page: _pdfPage, total: _pdfTotalPages, fileIndex: slidesIndex });
                    } else if (slidesIndex > 0) {
                        slidesIndex--;
                        loadSlide();
                    }
                    break;

                case 'slides-pdf-goto':
                    if (_pdfDoc && data.page >= 1 && data.page <= _pdfTotalPages) {
                        _pdfPage = data.page;
                        renderPdfPage();
                        sendCommand('pdf-page-update', { page: _pdfPage, total: _pdfTotalPages, fileIndex: slidesIndex });
                    }
                    break;

                case 'slides-video-play':
                    var v = document.getElementById('slideVideo');
                    if (v) v.play();
                    break;

                case 'slides-video-pause':
                    var v2 = document.getElementById('slideVideo');
                    if (v2) v2.pause();
                    break;

                case 'set-ambient':
                    if (data.mode) setAmbientMode(data.mode, data.text);
                    if (data.show) showScene('ambient');
                    break;

                case 'camera-offer':
                    handleCameraOffer(data.offer);
                    break;

                case 'camera-ice-candidate-controller':
                    if (_displayPC) {
                        _displayPC.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(function(){});
                    }
                    break;

                case 'camera-stop':
                    if (_displayPC) { _displayPC.close(); _displayPC = null; }
                    var cv = document.getElementById('cameraVideo');
                    cv.srcObject = null;
                    document.getElementById('cameraStatus').style.display = '';
                    document.getElementById('cameraStatus').textContent = 'Waiting for camera...';
                    break;

            }
        });

        // Block Cmd+P print dialog at capture phase before browser handles it
        window.addEventListener('keydown', function(e) {
            if ((e.metaKey || e.ctrlKey) && (e.key === 'p' || e.key === 'P')) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, true);

        document.addEventListener('keydown', function(e) {
            // B key — toggle ambient screen
            if (e.key === 'b' || e.key === 'B' || e.key === '.') {
                e.preventDefault();
                if (currentScene === 'ambient') {
                    if (_preAmbientScene) {
                        showScene(_preAmbientScene);
                        sendCommand('show-scene', { scene: _preAmbientScene });
                        _preAmbientScene = null;
                    }
                } else {
                    _preAmbientScene = currentScene;
                    showScene('ambient');
                    sendCommand('show-scene', { scene: 'ambient' });
                }
                return;
            }

            // Logitech clicker "start presentation" sends:
            // Cmd, Enter, Ctrl, Shift, Alt, Cmd+P, Shift+F5 then Escape on alternate press
            // Swallow the whole burst and treat as push-live
            if (e.key === 'F5' || e.key === 'Escape') {
                e.preventDefault();
                sendCommand('push-live');
                return;
            }
            if (e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                return;
            }
            if (e.key === 'Enter') {
                e.preventDefault();
                return;
            }

            // Arrow keys — slide navigation
            if (currentScene !== 'slides' || slidesFiles.length === 0) return;
            if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                e.preventDefault();
                if (slidesIndex < slidesFiles.length - 1) {
                    slidesIndex++;
                    loadSlide();
                    slidesLocalNav = true;
                    sendCommand('slides-next');
                }
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                e.preventDefault();
                if (slidesIndex > 0) {
                    slidesIndex--;
                    loadSlide();
                    slidesLocalNav = true;
                    sendCommand('slides-prev');
                }
            }
        });

        init();
    </script>
</body>
</html>